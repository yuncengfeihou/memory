### 描述
- 这个插件通过单独总结每条消息（而不是一次性全部总结）来重新设计内存的存储方式。
- 摘要会分两个层级注入到主提示词中：短期记忆和长期记忆。
- 短期记忆会自动轮换掉最新的消息摘要。
- 长期记忆存储手动标记的消息摘要，这些摘要超出了短期记忆的限制。

与内置摘要功能的优势对比：
- 单独总结消息（相较于一次性全部总结）能获得更准确的摘要，并且更不容易遗漏细节。
- 由于内存存储不由 LLM 处理，旧的摘要永远不会随时间改变。
- 每个摘要都附加到它所总结的消息上，因此删除一条消息只会移除相关的记忆。
- 短期记忆确保了最新消息中的相关信息始终可用，但一旦根据设定的限制不再相关，这些信息就会消失。
- 长期记忆允许您选择哪些细节是重要的并需要记住，使其在更长时间内可用，直至达到另一个独立的限制。

### 显著特性
- 配置档案：保存和加载不同的配置档案，并为每个角色或聊天设置一个自动加载的档案。
- 弹出式配置菜单：自定义摘要设置、注入设置以及自动摘要消息的包含标准。
- 一个独立的界面，用于查看和编辑聊天中的所有记忆。
- 摘要可以可选项地显示在每条消息下方的小字中，并根据其状态着色：
    - 绿色：包含在短期记忆中
    - 蓝色：标记为长期记忆（可能包含在短期或长期记忆中）
    - 红色：标记为长期记忆，但现在已超出上下文范围。
    - 灰色：已排除

### 安装与使用
- 在 ST 中使用 GitHub 链接安装此插件：https://github.com/qvink/qvink_memory
- 要将消息标记为长期记忆，请单击消息按钮菜单中的“大脑”图标。
- 要重新总结一条消息，请单击消息按钮菜单中的“引用”图标。
- 要编辑摘要，请直接单击摘要文本，或单击消息按钮菜单中的“笔”图标。
- 要同时对多个摘要执行操作，请转到配置菜单并单击“编辑记忆”。在这里，您可以筛选特定记忆或手动选择要修改的记忆。
- 在群聊中若只想总结特定角色的发言，请打开群聊编辑菜单，向下滚动到成员列表。单击发光的“大脑”图标，以切换该角色是否会被自动总结（如果您启用了自动总结功能）。

### 如何使用开发分支 (Dev branch)
**注意：开发分支要求您使用最新版本的 SillyTavern staging 分支。**

ST 没有简便的方法来切换插件分支，因此您需要使用 git。
在您的命令行中，进入插件存储的文件夹。
路径看起来类似 `SillyTavern/data/<user>/extensions/qvink_memory`。
然后在命令行中运行以下 git 命令：
- `git fetch origin dev:dev` （获取 dev 分支信息）
- `git checkout dev` （切换到 dev 分支）

之后，您可以使用 `git checkout master` 和 `git checkout dev` 来回切换。

当开发分支有更改时，要更新它，请运行：
- `git checkout dev` （首先确保您在 dev 分支上）
- `git pull origin dev` （拉取任何新的更改）

### 斜杠命令
- `/get_memory_enabled`：返回当前聊天中插件是否已启用。
- `/toggle_memory`：为当前聊天切换插件的启用/禁用状态。与在配置中单击“切换聊天记忆”相同。也可以提供布尔值参数直接切换插件状态。
- `/toggle_memory_display`：切换是否在每条消息下方显示摘要。与在配置中单击“显示记忆”相同。
- `/toggle_memory_popout`：切换弹出式配置菜单的显示/隐藏。
- `/toggle_memory_edit_interface`：切换“编辑记忆”界面的显示/隐藏。
- `/toggle_memory_injection_preview`：切换将要注入文本的预览显示/隐藏。
- `/summarize <n>`：总结聊天中的第 n 条消息（默认为最新消息）。与单击消息按钮菜单中的“引用”图标相同。
- `/summarize_chat`：对聊天执行一次自动总结，即使自动总结功能已禁用。
- `/stop_summarization`：停止当前正在运行的任何总结任务。与单击配置中或进度条旁边的“停止”按钮相同。
- `/remember <n>`：将第 n 条消息标记为长期记忆，如果尚未总结则进行总结。与单击消息按钮菜单中的“大脑”图标相同。
- `/force_exclude_memory <n>`：切换第 n 条消息摘要的包含状态。与单击消息按钮菜单中的“强制排除”按钮相同。
- `/get_memory <n>`：获取与第 n 条消息关联的记忆。默认为最新消息。

### 自定义 CSS
您可以使用以下类轻松自定义所显示记忆的 CSS 样式：
- `.qvink_short_memory`：在短期记忆中（默认为绿色）
- `.qvink_long_memory`：在长期记忆中（默认为蓝色）
- `.qvink_old_memory`：标记为长期记忆，但现在已超出上下文范围（默认为红色）
- `.qvink_exclude_memory`：手动强制排除（默认为深灰色）

只需确保使用 `!important` 指令来覆盖默认样式。
例如，要将短期记忆着色为黄色，您需要在您的“自定义 CSS”用户设置中添加以下内容：
```css
.qvink_short_memory {
   color: yellow !important;
}
```

### 提示
当然，每个模型都不同，但以下是我发现有助于获得清晰摘要的一些通用技巧。
如果您愿意，可以尝试一下。

- **保持简洁**：较长的摘要提示词往往会把水搅浑，导致结果不太准确。总的来说，LLM 难以处理信息过载（这也是开发此插件的原因）。
- **低 Temperature**：我喜欢使用 0 的 temperature 来减少创造性，专注于事实。不需要华丽的语言。
- **无重复惩罚 (Repetition Penalty)**：同样，不需要创造性，事实上我希望它重复发生的事情。
- **`{{words}}` 宏不总是有用**：虽然如果您告诉某些模型将字数控制在 X 以下，它们可能会自我约束，但 LLM 没有灵魂，因此不会计数，所以不要指望它。
- **您可以使用全局宏**：如果您的摘要未使用正确的名称，请记住您可以在提示词中使用 `{{char}}` 或 `{{user}}` 宏。
- **无需暂停角色扮演**：您不必包含诸如“忽略之前的指示”或“暂停您的角色扮演”之类的内容。摘要提示词是完全独立的，只会发送您在编辑窗口中看到的内容。
- **我不推荐使用推理 (Reasoning) 模型**：推理模型可以很好地进行总结，但它们往往会喋喋不休很长时间，这使得总结速度变慢，因此我不推荐它们。
- **保存您的预设**：如果您正在为摘要使用不同的补全预设 (completion preset) 或连接配置 (connection profile)，请确保保存对常规补全预设或指令模板 (instruct template) 所做的任何更改。进行总结时，插件必须临时切换预设或连接配置，这将丢弃您当前使用的配置中任何未保存的更改。

### 故障排除：

- **"ForbiddenError: invalid csrf token":** 您在多个标签页中打开了 ST。

- **"Syntax Error: No number after minus sign in JSON at position X":** 更新您的 koboldcpp，或尝试禁用“请求令牌概率 (Request token probabilities)”。

- **"min new tokens must be in (0, max_new_tokens(X)], got Y":** 您的模型设置了最小 token 数量，这与您用于摘要的最大 token 数量冲突。请减少模型的最小 token 数量（通常在补全设置中），或增加摘要的最大 token 长度。

- **摘要似乎在继续对话而不是进行总结：** 可能是您的指令模板 (instruct template) 有问题。确保您为模型使用了正确的模板，并确保系统消息与用户消息有适当区分（摘要使用系统提示词）。这可能是由指令模板设置中的“系统与用户相同 (System same as user)”复选框引起的，它会导致所有系统消息都被视为用户消息 - 如果您的模型可以处理，请取消选中该框。一些默认的指令模板也可能没有为“系统消息序列 (System message sequences)”字段定义任何内容 - 该字段应该被填写。您也可以尝试在设置中切换“在摘要提示词中嵌套消息 (Nest Message in Summary Prompt)” - 有些模型在这种设置下表现更好。

- **我的越狱 提示词(jailbreak) 不起作用：** 如果您希望包含越狱提示提示词，需要将其放入摘要提示词中。

- **摘要提到“一个人”或“某人”而不是角色的名字：** 尝试在摘要提示词中使用 `{{user}}` 或 `{{char}}` 宏。还有一个“消息历史记录 (Message History)”设置，可以在摘要提示词中包含几条先前的消息，为模型提供更多上下文。

- **摘要太长：** 您可以在设置中选择一个自定义的补全预设 (completion preset) 用于摘要，并用它来设置最大 token 长度，超过该长度的生成内容将被截断。您也可以在摘要提示词中使用 `{{words}}` 宏来尝试引导 LLM 遵循该 token 长度，但 LLM 实际上无法计算单词数，所以这真的只是一个建议。

- **即使在高级格式设置中勾选了选项，不完整的句子也没有被修剪：** 如果您正在为摘要使用不同的连接配置，请注意指令模板是其中的一部分，因此需要在该连接配置使用的模板中检查并勾选该选项。

- **当我为摘要使用不同的补全预设时，我的常规补全预设在总结后被更改了：** 生成摘要时，我们实际上必须临时切换补全预设，这会丢弃您可能对当前补全预设所做的任何未保存的更改。这只是 ST 的工作方式。这也适用于连接配置（进而影响指令模板）。

- **刚刚更新后出现问题：** 首先尝试重新加载页面，并确保您使用的是最新版本的 ST。如果您使用的是此插件的 dev 分支，则您也必须使用 ST 的 staging 分支。

如果是其他问题，请在设置中打开“调试模式 (Debug Mode)”，并将浏览器控制台的输出日志发送给我，并在 GitHub 上提出 issue 或在 Discord 上留言。

### 已知问题
- 当使用消息限制时，世界书条目 (World Info) 冷却和粘性计时效果 (sticky timed effects) 无法正常工作。这是因为 WI 计时效果依赖于生成期间聊天历史记录中的消息数量。我尚未找到解决方法。
- 编辑已有记忆的消息时，消息下方显示的记忆颜色不正确。这只是一个视觉错误，在下次总结后会自行纠正。